Aurora MySQL만으로 실시간 시청자수(입·퇴장 이벤트)를 전부 처리하려 하면 락 경합, TPS 한계, 확장성 문제가 생깁니다.
Redis를 중간 계층으로 두면 이런 병목이 크게 줄어듭니다.

1. 락 경합(UPDATE 경합) 문제 해결

    Aurora MySQL만 사용 시

        UPDATE current_viewers SET viewer_count = viewer_count + 1 WHERE stream_id = ...

        인기 방송에 수천 명이 동시에 입장하면 같은 stream_id 레코드에 동시 UPDATE 경합이 발생.

        InnoDB의 레코드 락(Record Lock) 때문에 CPU는 남는데 TPS가 오르지 않는 현상 발생.

        예: 초당 1,000 요청 중 하나만 처리되고 나머지 999건은 대기 → 평균 대기 10초 이상.

    Redis 도입 후

        시청자수 변경을 Redis 메모리 카운터에서 즉시 처리 (INCR, DECR는 락 없이 O(1) 연산).

        Aurora는 5분 단위 배치로 Redis 값을 읽어와 집계 → DB 동시 UPDATE 거의 사라짐.

2. TPS 한계 완화

    Aurora MySQL만 사용 시

        100만 동시접속 환경의 피크(6,600 TPS) + 인기 방송 순간 폭증(11,000 TPS)을 전부 DB가 처리해야 함.

        InnoDB Buffer Pool, Redo Log, WAL 쓰기 병목으로 TPS 제한 발생.

    Redis 도입 후

        Redis는 초당 수십만 건의 INCR/DECR 연산도 처리 가능.

        Aurora는 실시간 쓰기 부하에서 해방 → TPS 여유 확보.

3. 읽기 부하 감소

    Aurora MySQL만 사용 시

        실시간 시청자 표시를 위해 초당 수천 건의 SELECT viewer_count FROM current_viewers 발생.

        이 부하가 Reader 노드로 몰리면 복제 지연이 커지고 읽기 TPS도 한계 도달.

    Redis 도입 후

        조회는 Redis 슬레이브에서 즉시 응답(1~2ms).

        DB 조회 없이도 실시간 숫자를 화면에 노출.

4. 확장성(Scale-out) 확보

    Aurora MySQL만 사용 시

        쓰기는 Writer 한 대에서만 처리 가능 → 수평 확장 불가.

        Reader 노드만 늘려도 쓰기 성능은 그대로.

    Redis 도입 후

        Redis Cluster 마스터 노드 수를 늘려 쓰기/읽기 모두 수평 확장 가능.

        샤딩을 통해 방송별 시청자 데이터 분산 저장.

5. 장애 격리

    Aurora MySQL만 사용 시

        DB에 순간 폭증 트래픽이 들어오면 전체 서비스가 느려짐.

        인기 방송 하나의 시청자수 폭증이 다른 방송 데이터까지 영향.


    Redis 도입 후

        Redis에서 폭증을 흡수하고 Aurora에는 집계 결과만 전달.

        DB는 안정적인 배치 쓰기 중심으로 운영.

📌 정리
Redis를 중간에 두면 Aurora MySQL의 가장 큰 약점인 고빈도 단일 레코드 UPDATE와 TPS 한계를 피할 수 있고,
실시간 응답 속도(1~2ms)와 확장성을 모두 확보할 수 있습니다.
Aurora는 “실시간” 대신 “정확한 집계 저장소”로 역할이 바뀌어 안정성이 크게 향상됩니다.